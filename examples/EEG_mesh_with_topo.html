
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>4D Meshes - EEG topography</title>
	<link rel="stylesheet" href="../niivue_dualview.css" />
  </head>
  <body>
    <noscript>
      <strong
        >niivue doesn't work properly without JavaScript enabled. Please enable
        it to continue.</strong
      >
    </noscript>
    <header>
	<h3>Investigate the effect of single brain sources on the EEG voltage map</h3>
	<p>EEG electrodes are represented as yellow spheres, the voltage map is colour coded (red: positive values, blue: negative values).<br>
	'Brain' source slider enables you to change the source location (if clicked, key arrows wors as well),
	'Gamma' slider enables you to change the contrast, radio button X, Y and Z permits to change the orientation of the dipole source.</p>
		<div class='row'>
			<div style="outline: #505050 2px solid; padding: 2px 10px;">
			<label for="meshXRay">XRay</label>
			<input type="range" min="0" max="10" value="3" class="slider" id="meshXRay" />
			</div>
			<div style="outline: #505050 2px solid; padding: 2px 10px;">
			<label for="meshMinSlider">Min threshold</label>
			<input
				type="range"
				min="0"
				max="1000"
				value="0"
				class="slider"
				id="meshMinSlider"
			/>
			</div>
			<div style="outline: #505050 2px solid; padding: 2px 10px;">
			<label for="meshMaxSlider">Max threshold</label>
			<input
				type="range"
				min="0"
				max="1000"
				value="1000"
				class="slider"
				id="meshMaxSlider"
			/>
			</div>
			<div style="outline: #505050 2px solid; padding: 2px 10px;">
			<label for="gammaSlider">Gamma</label>
			<input
				type="range"
				min="10"
				max="400"
				value="100"
				class="slider"
				id="gammaSlider"
			/>
			</div>
			<div style="outline: #505050 2px solid; padding: 2px 10px;">
			Source orientation:
			<label for="oriXbtn">X</label>
			<input type="radio" id="oriX" name="sourceOri" value="showNode" checked>
			<label for="oriYbtn">Y</label>
			<input type="radio" id="oriY" name="sourceOri" value="showNodeSubNet">
			<label for="oriZbtn">Z</label>
			<input type="radio" id="oriZ" name="sourceOri" value="showNode">
			</div>
			<div style="outline: #505050 2px solid; padding: 2px 10px;">
			<label for="normLeadfield">Normalised Leadfield</label>
			<input type="checkbox" id="normLeadfield" checked />
			</div>
		</div>
		<label for="srcSlider">Brain source</label>
		<button id="prevSource">back</button>
		<input
			type="range"
			min="0"
			max="1156"
			value="0"
			class="slider"
			style="width:50%"
			id="srcSlider"
		/>
		<button id="nextSource">forward</button>
</header>
    <main id="container">
	<div class='page-wrapper'>
        <div class='row'>
          <div class='column'>
              <canvas id="gl1">
          </div>
          <div class='column'>
              <canvas id="gl2">
          </div>
        </div>
    </div>
    </main>
  </body>
</html>
<script type="module" async>
  import * as niivue from "https://cdn.jsdelivr.net/npm/@niivue/niivue@0.46.0/dist/index.js";
  
  var srcSlider = document.getElementById("srcSlider");
  var minSlider = document.getElementById("meshMinSlider");
  var maxSlider = document.getElementById("meshMaxSlider");
  var Xbtn = document.getElementById('oriX')
  var Ybtn = document.getElementById('oriY')
  var Zbtn = document.getElementById('oriZ')
  const response = await fetch("https://roehrin.github.io/test/src/source_points.jcon", {})
  const srcPos = await response.json()
  var currSrcPos = [srcPos.nodes.X[0], srcPos.nodes.Y[0], srcPos.nodes.Z[0]];
  function updateCrosshairPos(){
	let dPos = nv1.mm2frac(currSrcPos); // current position of the source, mm convert to frac
	nv1.scene.crosshairPos = dPos;
    nv1.createOnLocationChange()
    nv1.drawScene()
  }
  meshXRay.oninput = function () {
        nv1.opts.meshXRay = this.value * 0.1
        nv1.drawScene()
  }
  Xbtn.onclick = function () {
	nv1.meshes[2].nodes[1] = {
        name: "target",
        x: currSrcPos[0]+10,
        y: currSrcPos[1],
        z: currSrcPos[2],
        colorValue: 1,
        sizeValue: 2.5
      };
	nv1.meshes[2].updateMesh(nv1.gl)
	nv1.setMeshLayerProperty(nv1.meshes[0].id, 0, "frame4D", 3*srcSlider.valueAsNumber+0);
	nv2.setMeshLayerProperty(nv2.meshes[0].id, 0, "frame4D", 3*srcSlider.valueAsNumber+0);
  };
  Ybtn.onclick = function () {
	nv1.meshes[2].nodes[1] = {
        name: "target",
        x: currSrcPos[0],
        y: currSrcPos[1]+10,
        z: currSrcPos[2],
        colorValue: 1,
        sizeValue: 2.5
      };
	nv1.meshes[2].updateMesh(nv1.gl)
	nv1.setMeshLayerProperty(nv1.meshes[0].id, 0, "frame4D", 3*srcSlider.valueAsNumber+1);
	nv2.setMeshLayerProperty(nv2.meshes[0].id, 0, "frame4D", 3*srcSlider.valueAsNumber+1);
  };
  Zbtn.onclick = function () {
	nv1.meshes[2].nodes[1] = {
        name: "target",
        x: currSrcPos[0],
        y: currSrcPos[1],
        z: currSrcPos[2]+10,
        colorValue: 1,
        sizeValue: 2.5
      };
	nv1.meshes[2].updateMesh(nv1.gl)
	nv1.setMeshLayerProperty(nv1.meshes[0].id, 0, "frame4D", 3*srcSlider.valueAsNumber+2);
	nv2.setMeshLayerProperty(nv2.meshes[0].id, 0, "frame4D", 3*srcSlider.valueAsNumber+2);
  };
  minSlider.oninput = function () {
    nv1.setMeshLayerProperty(nv1.meshes[0].id, 0, "cal_min", this.value * 0.1);
	nv2.setMeshLayerProperty(nv2.meshes[0].id, 0, "cal_min", this.value * 0.1);
  };
  maxSlider.oninput = function () {
    nv1.setMeshLayerProperty(nv1.meshes[0].id, 0, "cal_max", this.value * 0.1);
	nv2.setMeshLayerProperty(nv2.meshes[0].id, 0, "cal_max", this.value * 0.1);
  };
  srcSlider.oninput = function () {
	let ori_idx = 0;
	if (Ybtn.checked){
		ori_idx = 1;
	} else if (Zbtn.checked){
		ori_idx = 2;
	}
	// leadfield.gii contains 1 every 5 sources, hence the 5*
	currSrcPos = [srcPos.nodes.X[5*this.value], srcPos.nodes.Y[5*this.value], srcPos.nodes.Z[5*this.value]];
	updateCrosshairPos()
	nv1.meshes[2].nodes = [
      {
        name: "source",
        x: currSrcPos[0],
        y: currSrcPos[1],
        z: currSrcPos[2],
        colorValue: 1,
        sizeValue: 5
      },
      {
        name: "target",
        x: currSrcPos[0]+10*Xbtn.checked,
        y: currSrcPos[1]+10*Ybtn.checked,
        z: currSrcPos[2]+10*Zbtn.checked,
        colorValue: 1,
        sizeValue: 2.5
      }
    ];
	nv1.meshes[2].updateMesh(nv1.gl)
	nv1.setMeshLayerProperty(nv1.meshes[0].id, 0, "frame4D", 3*(this.value)+ori_idx);
	nv2.setMeshLayerProperty(nv2.meshes[0].id, 0, "frame4D", 3*(this.value)+ori_idx);
  };
  normLeadfield.onclick = async function() {
	nv1.meshes[0].layers = []; // remove current layer
	nv2.meshes[0].layers = []; // remove current layer
	if (normLeadfield.checked){
		meshLayersList1 = [
		{
			url: "https://roehrin.github.io/test/src/norm_leadfield.gii",
			colormap: "hot",
			colormapNegative: "electric_blue",
			cal_min: 0,
			cal_max: 100,
			useNegativeCmap: true,
			opacity: 1,
		},
		];
	} else {
		meshLayersList1 = [
		{
			url: "https://roehrin.github.io/test/src/leadfield.gii",
			colormap: "hot",
			colormapNegative: "electric_blue",
			cal_min: 0,
			cal_max: 100,
			useNegativeCmap: true,
			opacity: 1,
		},
		];
	}
	await niivue.NVMesh.loadLayer(meshLayersList1[0], nv1.meshes[0])
	nv1.meshes[0].updateMesh(nv1.gl)
	await niivue.NVMesh.loadLayer(meshLayersList1[0], nv2.meshes[0])
	nv2.meshes[0].updateMesh(nv2.gl)
	srcSlider.oninput()
	nv1.drawScene()
	nv2.drawScene()
	}
  var gamSlider = document.getElementById("gammaSlider");
  gamSlider.oninput = function () {
	
    nv1.setGamma(this.value * 0.01);
	nv2.setGamma(this.value * 0.01);
	nv1.setMeshProperty(0, "edgeMin", 0) // little trick to update the mesh otherwise only the volume is updated
	nv2.setMeshProperty(0, "edgeMin", 0)
  };
  var nv1 = new niivue.Niivue({
    show3Dcrosshair: true,
	isColorbar: false,
	showLegend: false,
    backColor: [0.9, 0.9, 1, 1],
	meshXRay: .5,
	isOrientCube: true,
  });
  nv1.setSliceType(nv1.sliceTypeRender);
  nv1.attachTo("gl1");
  var meshLayersList1 = [
    {
      url: "https://roehrin.github.io/test/src/norm_leadfield.gii",
	  colormap: "hot",
	  colormapNegative: "electric_blue",
	  cal_min: 0,
      cal_max: 100,
      useNegativeCmap: true,
      opacity: 1,
    },
  ];
  // draw dipole using connectome variable
  var dipole = {name: "dipole",
    nodeColormap: "hot",
    nodeColormapNegative: "",
    nodeMinColor: 0,
    nodeMaxColor: 1,
    nodeScale: 1, //scale factor for node, e.g. if 2 and a node has size 3, a 6mm ball is drawn
    edgeColormap: "hot",
    edgeColormapNegative: "",
    edgeMin: 0,
    edgeMax: 2.5,
    edgeScale: 1,
    legendLineThickness: 0,
    nodes: [
      {
        name: "source",
        x: currSrcPos[0],
        y: currSrcPos[1],
        z: currSrcPos[2],
        colorValue: 1,
        sizeValue: 5
      },
      {
        name: "target",
        x: currSrcPos[0]+10,
        y: currSrcPos[1],
        z: currSrcPos[2],
        colorValue: 1,
        sizeValue: 2.5
      }
    ],
    edges: [{
      first: 0,
      second: 1,
      colorValue: 2.5
    }],
  }   //dipole{}
  //await nv1.loadVolumes(volumeList1);
  await nv1.loadMeshes([
    {
      url: "https://roehrin.github.io/test/src/leadfield.gii",
	  layers: meshLayersList1,
    },
	{
      url: "https://roehrin.github.io/test/src/EGI257_electrodes.jcon",
    },
  ]);
  
  //await nv1.loadConnectome(dipole)
  nv1.addMesh(nv1.loadConnectomeAsMesh(dipole))
  nv1.drawScene()
  nv1.setMeshShader(nv1.meshes[0].id, "Diffuse");
  updateCrosshairPos()
  nv1.setRenderAzimuthElevation(0, 90);
  var nv2 = new niivue.Niivue({
    show3Dcrosshair: false,
	isColorbar: true,
	showLegend: false,
    backColor: [0.9, 0.9, 1, 1],
	meshXRay: 0,
	isOrientCube: false,
  });
  nv2.attachTo("gl2");
  await nv2.loadMeshes([
    {
	  url: "https://roehrin.github.io/test/src/leadfield2D.gii",
	  layers: meshLayersList1,
    },
	{
	  url: "https://roehrin.github.io/test/src/EGI257_2Dlayout.jcon",
    }
  ]);
  nv2.setMeshShader(nv2.meshes[0].id, "Diffuse");
  nv2.setMeshProperty(nv2.meshes[1].id, "nodeScale", 1)
  nv2.meshes[1].colorbarVisible = false;
  nv2.setRenderAzimuthElevation(0, 90);
  prevSource.onclick = function () {
		srcSlider.value = String(srcSlider.valueAsNumber-1);
		srcSlider.oninput();
	}
	nextSource.onclick = function () {
		srcSlider.value = String(srcSlider.valueAsNumber+1);
		srcSlider.oninput();
	}
	nv2.updateGLVolume()
</script>
